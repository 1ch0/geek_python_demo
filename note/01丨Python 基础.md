---
author: 1ch0
index_img: https://raw.githubusercontent.com/1ch0/Figure-bed/main/img/python-programming.jpg
date: 2022-01-12-星期三 15:37
update: 2022-01-12-Wednesday 15:40:37
tags: Python
categories: Python
hide: false
title: Python核心技术与实战-基础篇 
---

# Python核心技术与实战-基础篇

## 1. 列表和元组

### 1.1 基础

- 列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。
- 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。
- Python 中的列表和元组都支持负数索引，-1 表示最后一个元
  素，-2 表示倒数第二个元素，以此类推。
- 列表和元组都支持切片操作
- 列表和元组都可以随意嵌套
- 两者也可以通过 list() 和 tuple() 函数相互转换

### 1.2 存储方式的差异

- 列表是动态的、可变的，而元组是静态的、不可变的
- 由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。

### 1.3 性能

- 元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。

- Python 会在后台，对静态数据做一些资源缓存（resource caching）。对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。

- 元组的初始化速度，要比列表快 5 倍。

  ```python
  python3 -m timeit 'x=(1,2,3,4,5,6)'
  20000000 loops, best of 5: 9.97 nsec per loop
  python3 -m timeit 'x=[1,2,3,4,5,6]'
  5000000 loops, best of 5: 50.1 nsec per loop
  ```

- 如果是索引操作的话，两者的速度差别非常小，几乎可以忽略不计。

  ```python
  python3 -m timeit -s 'x=[1,2,3,4,5,6]' 'y=x[3]'
  10000000 loops, best of 5: 22.2 nsec per loop
  python3 -m timeit -s 'x=(1,2,3,4,5,6)' 'y=x[3]'
  10000000 loops, best of 5: 21.9 nsec per loop
  ```

### 1.4 使用场景

1. 如果存储的数据和数量不变，选用元组更合适。
2. 如果存储的数据或数量是可变的，用列表更合适。

```ad_summary
总的来说，列表和元组都是有序的，可以存储任意数据类型的集合，区别主要在于下面这两点。
- 列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元
组，性能略逊于元组。
- 元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于
列表更加轻量级，性能稍优。

元素不需要改变时:
两三个元素，使用 tuple，元素多一点使用namedtuple。
元素需要改变时:
需要高效随机读取，使用list。需要关键字高效查找，采用 dict。去重，使用 set。大型数
据节省空间，使用标准库 array。大型数据高效操作，使用 numpy.array。
```

## 2. 字典和集合

### 2.1 基础

- 字典是一系列由键（key）和值（value）配对组成的元素的集合，在 Python3.7+，字典被确定为有序（注意：在 3.6 中，**字典有序**是一个implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。
- 相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数
  时间复杂度内完成。
- 集合和字典基本相同，唯一的区别，就是**集合没有键和值的配对，是一系列无序的、唯一的元素组合**。
- **Python 中字典和集合，无论是键还是值，都可以是混合类型。**
- 

#### 2.1.1 元素访问

- 字典访问可以直接索引键，如果不存在，就会抛出异常

  使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值

- 集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样

  判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断

- 字典和集合也同样支持增加、删除、更新等操作

  ```python
  d = {'name': 'jason', 'age': 20}
  d['gender'] = 'male' # 增加元素对'gender': 'male'
  d['dob'] = '1999-02-01' # 增加元素对'dob': '1999-02-01'
  d
  {'name': 'jason', 'age': 20, 'gender': 'male', 'dob': '1999-02-01'}
  d['dob'] = '1998-01-01' # 更新键'dob'对应的值
  d.pop('dob') # 删除键为'dob'的元素对
  '1998-01-01'
  d
  {'name': 'jason', 'age': 20, 'gender': 'male'}
  s = {1, 2, 3}
  s.add(4) # 增加元素 4 到集合
  s
  {1, 2, 3, 4}
  s.remove(4) # 从集合中删除元素 4
  s
  {1, 2, 3}
  ```

- 集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你
  无法知道会删除哪个元素，因此这个操作得谨慎使用

#### 2.1.2 排序

- 对于字典，我们通常会根据键或值，进行升序或降序排序

  ```python
  d = {'b': 1, 'a': 2, 'c': 10}
  d_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 根据字典键的升序排序
  d_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 根据字典值的升序排序
  d_sorted_by_key
  [('a', 2), ('b', 1), ('c', 10)]
  d_sorted_by_value
  [('b', 1), ('a', 2), ('c', 10)]
  ```

- 对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表

  ```python
  s = {3, 4, 2, 1}
  sorted(s) # 对集合的元素进行升序排序
  ```

### 2.2 性能

> 字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作

假设列表有 n 个元素，而查找的过程要遍历列表，那么时间复杂度就为 O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要 O(logn) 的时间复杂度，更何况，列表的排序还需要 O(nlogn) 的时间。

```python
def find_product_price(products, product_id):
    for id, price in products:
        if id == product_id:
            return price
    return None

products = [
    (143121312, 100),
    (432314553, 30),
    (32421912367, 150)
]
print('The price of product 432314553 is {}'.format(find_product_price(products,432314553)))
```

但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需 O(1) 的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。

```python
products = {
143121312: 100,
432314553: 30,
32421912367: 150
}
print('The price of product 432314553 is {}'.format(products[432314553]))
```

### 2.3 工作原理

- 不同于其他数据结构，字典和集合的内部结构都是一张哈希表

  - 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。
  - 对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。

- 为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构

  ```shell
  Indices
  ----------------------------------------------------
  None | index | None | None | index | None | index ...
  ----------------------------------------------------
  
  Entries
  --------------------
  hash0 key0 value0
  ---------------------
  hash1 key1 value1
  ---------------------
  hash2 key2 value2
  ---------------------
  ...
  ---------------------
  ```

### 2.4 插入操作

每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index =hash(key) & mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。

而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。

- 若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。
- 若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。

值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python 内部对此进行了优化

### 2.5 查找操作

和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。

### 2.6 删除操作

对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。

不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。

虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。

```ad-summary
字典在 Python3.7+ 是有序的数据结构，而集合是无序的，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。所以，字典和集合通常运用在对元素的高效查找、去重等场景。
```

## 3. 字符串

### 3.1 基础

- 字符串是由独立字符组成的一个序列，通常包含在单引号（''）双引号（""）或者三引号之中（''' '''或""" """，两者一样）

- Python 中单引号、双引号和三引号的字符串是一模一样的，没有区别

- Python 也支持转义字符。所谓的转义字符，就是用反斜杠开头的字符串，来表示一
  些特定意义的字符

  | 转义字符 | 说明        |
  | -------- | ----------- |
  | \newline | 接下一行    |
  | \\\      | 表示 \      |
  | \\'      | 表示单引号' |
  | \\"      | 表示双引号  |
  | \\n      | 换行        |
  | \\t      | 横向制表符  |
  | \\b      | 退格        |
  | \\v      | 纵向制表符  |

### 3.2 常用操作

- 字符串的索引同样从 0 开始，index=0 表示第一个元素（字符），[index:index+2] 则表示第 index 个元素到 index+1 个元素组成的子字符串。

- 遍历字符串同样很简单，相当于遍历字符串中的每个字符。

- Python 的字符串是不可变的（immutable）。因此，用下面的操作，来改变一个字符串内部的字符是错误的，不允许的。

- Python 中字符串的改变，通常只能通过创建新的字符串来完成。比如上述例子中，想把'hello'的第一个字符'h'，改为大写的'H'，我们可以采用下面的做法：

  ```python
  s = 'H' + s[1:]
  s = s.replace('h', 'H')
  ```

  - 第一种方法，是直接用大写的'H'，通过加号'+'操作符，与原字符串切片操作的子字符串拼接而成新的字符串。
  - 第二种方法，是直接扫描原字符串，把小写的'h'替换成大写的'H'，得到新的字符串。

- 使用加法操作符'+='的字符串拼接方法,在写程序遇到字符串拼接时，如果使用’+='更方便，就放心地去用吧，不用过分担心效率问题了

- 除了使用加法操作符，我们还可以使用字符串内置的 join 函数。string.join(iterable)，表示把每个元素都按照指定的格式连接起来

- 常见的函数还有：

  - string.strip(str)，表示去掉首尾的 str 字符串；
  - string.lstrip(str)，表示只去掉开头的 str 字符串；
  - string.rstrip(str)，表示只去掉尾部的 str 字符串。
  - 从文件读进来的字符串中，开头和结尾都含有空字符，我们需要去掉它们，就可以用 strip() 函数
  - Python 中字符串还有很多常用操作，比如，string.find(sub, start, end)，表示从start 到 end 查找字符串中子字符串 sub 的位置

### 3.3 格式化

- 使用一个字符串作为模板，模板中会有格式符。这些格式符为后续真实值预留位置，以呈现出真实值应该呈现的格式。字符串的格式化，通常会用在程序的输出、logging等场景。

  ```python
  print('no data available for person with id: {}, name: {}'.format(id, name))
  ```

  其中的 string.format()，就是所谓的格式化函数；而大括号{}就是所谓的格式符，用来为后面的真实值——变量 name 预留位置

- string.format() 是最新的字符串格式函数与规范。自然，我们还有其他的表示方法，比如在 Python 之前版本中，字符串格式化通常用 % 来表示

  ```python
  print('no data available for person with id: %s, name: %s' % (id, name))
  ```

  其中 %s 表示字符串型，%d 表示整型等等，这些属于常识

  推荐使用 format 函数，毕竟这是最新规范，也是官方文档推荐的规范。

- 使用格式化函数，更加清晰、易读，并且更加规范，不易出错。

```ad_summary
Python 中字符串使用单引号、双引号或三引号表示，三者意义相同，并没有什么区别。其中，三引号的字符串通常用在多行字符串的场景。
Python 中字符串是不可变的（前面所讲的新版本 Python 中拼接操作’+='是个例外）。因此，随意改变字符串中字符的值，是不被允许的。
Python 新版本（2.5+）中，字符串的拼接变得比以前高效了许多，你可以放心使用。
Python 中字符串的格式化（string.format）常常用在输出、日志的记录等场景。
```

